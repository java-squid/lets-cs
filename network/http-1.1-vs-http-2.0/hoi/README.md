# HTTP/1.1 vs HTTP/2.0

### HTTP 1.1

**HTTP/1.1**는 **HTTP/1.0**의 표준 버전이 나혼 이후에 몇달이 안되서 여러 사항이 개선되어 나온 현재까지 가장 많이 사용하는 표준 프로토콜 입니다.

### **HTTP/1.1 Connection**

**Connection**이 재사용될 수 있게 하여 임베드 된 탐색된 단일 문서들을 디스플레이하기 위해 **Connection**을 다시 열어서 사용했습니다. 추가적으로 HTTP/1.1 **Connection**의 동작은 하나의 **Connection**에 하나의 요청을 처리하도록 설계가 되어있습니다. HTTP/1.1의 단점이라고 불리는 것들은 **`Connection**에 하나의 요청을 처리` 의 특징과 관계가 많습니다.

### HOL ( Head Of Line ) : 응답 지연

Head Of Line은 같은 큐의 첫번째 이 후 후순에 있는 작업 큐들이 첫 번째 패킷에 의해서 지연될 때 발생하는 성능 저하를 의미합니다. 단순하게는 처리 속도가 지연되고 최악의 경우 패킷 드랍의 경우까지 갈 수 있습니다.

스위치는 패킷을 받는 3가지 순서로 구성되어 있습니다.

`input` → `switching fabric` → `output`

[switching fabric에 대한 글](https://www.netmanias.com/ko/post/qna/3127)

아래의 사진은 첫 번째와 세 번째 입력이 같은 output(4)을 바라볼 때 switching fabric이 3번을 먼저 처리해버린다면 1번 입력 패킷은 첫번째 입력을 인터페이스로 보내지 못하게 됩니다. 순차적으로 처리하는 특성과 output의 제한으로 발생하는 현상을 `HOL Blocking` 라고 합니다.

<img width="571" alt="스크린샷 2021-05-17 오후 11 20 52" src="https://user-images.githubusercontent.com/49897409/118513578-d0a9b300-b76e-11eb-952f-041a78d236ea.png">

### RTL ( Route Trip Time ) : 불필요한 과정의 증가

HTTP/1.1 특징 중 하나에 `Connection` 은 하나의 일만 처리한다는 특징이 있습니다. 이럴 때 매번 요청마다 TCP의 `3-way Handshake`가 반복됩니다. `3-way Handshake` 같이 인증의 과정을 거치는 건 결국에 일련의 처리 과정을 거치는데 리소스를 투자하는 것으로 이해할 수 있으며 이는 네트워크 지연에 영향을 줍니다.

### 무거운 Header 구조

**추가적으로 알아보면 좋은 토픽**

- HTTP 파이프라이닝

### HTTP 2.0

<img width="717" alt="스크린샷 2021-05-17 오후 11 37 22" src="https://user-images.githubusercontent.com/49897409/118513646-e5864680-b76e-11eb-8a94-fa04ef5a3ac4.png">

위의 사진은 HTTP/1.1의 동시 전송 문제가 HTTP/2.0에서는 어떻게 처리되는지 나타냅니다. 순서를 지켜가며 통신이 이뤄지는 1.1과는 달리 2.0에서는 순서에 상관없이 응답을 받고 있습니다.

### Multiplexed Streams

`Multiplexed Streams` 의 특징은 한 커넥션으로 동시에 여러개의 메시지를 통신 할 수 있으며 수신에 있어서 순서가 상관 없다 라는 특징이 있습니다.

### Stream Prioritization

스트림의 우선 순위를 지정하여 웹이 받는 리소스를 보다 효과적으로 제어할 수 있습니다. HTML의 문서를 읽을 때 이미지 파일보다 CSS 파일 수신에 우선 순위를 두는 방식으로 렌더링을 보다 효과적으로 할 수 있습니다.

- HTML 파일을 수신하고 웹 브라우저가 이를 읽는다.
- 우선 순위가 더 높은 CSS파일의 수신이 먼저 이뤄지고 웹 브라우저는 HTML DOM과 CSSOM 구조를 만들어 렌더링을 진행한다.
- 화면에 필요한 이미지 리소스를 요청하고 해당 위치에 렌더링을 진행한다.

### Header Compression

위에서 HTTP/1.1에서는 무거운 헤더 구조가 단점 중 하나로 말했는데 HTTP/2.0에서는 아래와 같은 방식으로 Header를 압축합니다. 이를 HPACK 압축방식이라 부릅니다.

### Server Push

클라이언트가 HTTP 문서를 수신한 후 HTTP/1.1은 리소스 요청이 필요한 라인에서 해당 리소스를 다시 서버에 요청하게 됩니다. 예를 들어서 아래의 과정과 같습니다.

- HTML 구문 분석 중
- CSS 파일을 만났다.
- CSS 파일 요청
- HTML 구문 분석 중
- 이미지 파일을 만났다.
- 이미지 파일 요청

하지만 HTTP/2.0 에서는 클라이언트가 요청할 리소스를 예측하여 해당 정보를 같이 보내는 방법으로 클라이언트의 추가적인 요청을 최소화 해줍니다. 이를 PUSH_PROMISE라고 부릅니다.

### HTTP 1.1

**HTTP/1.1**는 **HTTP/1.0**의 표준 버전이 나혼 이후에 몇달이 안되서 여러 사항이 개선되어 나온 현재까지 가장 많이 사용하는 표준 프로토콜 입니다.

### **HTTP/1.1 Connection**

**Connection**이 재사용될 수 있게 하여 임베드 된 탐색된 단일 문서들을 디스플레이하기 위해 **Connection**을 다시 열어서 사용했습니다. 추가적으로 HTTP/1.1 **Connection**의 동작은 하나의 **Connection**에 하나의 요청을 처리하도록 설계가 되어있습니다. HTTP/1.1의 단점이라고 불리는 것들은 **`Connection**에 하나의 요청을 처리` 의 특징과 관계가 많습니다.

### HOL ( Head Of Line ) : 응답 지연

Head Of Line은 같은 큐의 첫번째 이 후 후순에 있는 작업 큐들이 첫 번째 패킷에 의해서 지연될 때 발생하는 성능 저하를 의미합니다. 단순하게는 처리 속도가 지연되고 최악의 경우 패킷 드랍의 경우까지 갈 수 있습니다.

스위치는 패킷을 받는 3가지 순서로 구성되어 있습니다.

`input` → `switching fabric` → `output`

[switching fabric에 대한 글](https://www.netmanias.com/ko/post/qna/3127)

아래의 사진은 첫 번째와 세 번째 입력이 같은 output(4)을 바라볼 때 switching fabric이 3번을 먼저 처리해버린다면 1번 입력 패킷은 첫번째 입력을 인터페이스로 보내지 못하게 됩니다. 순차적으로 처리하는 특성과 output의 제한으로 발생하는 현상을 `HOL Blocking` 라고 합니다.

<img width="560" alt="스크린샷 2021-05-17 오후 11 55 55" src="https://user-images.githubusercontent.com/49897409/118513722-f33bcc00-b76e-11eb-8083-447f1f9fb75b.png">

### RTL ( Route Trip Time ) : 불필요한 과정의 증가

HTTP/1.1 특징 중 하나에 `Connection` 은 하나의 일만 처리한다는 특징이 있습니다. 이럴 때 매번 요청마다 TCP의 `3-way Handshake`가 반복됩니다. `3-way Handshake` 같이 인증의 과정을 거치는 건 결국에 일련의 처리 과정을 거치는데 리소스를 투자하는 것으로 이해할 수 있으며 이는 네트워크 지연에 영향을 줍니다.

### 무거운 Header 구조

**추가적으로 알아보면 좋은 토픽**

- HTTP 파이프라이닝

### HTTP 2.0

위의 사진은 HTTP/1.1의 동시 전송 문제가 HTTP/2.0에서는 어떻게 처리되는지 나타냅니다. 순서를 지켜가며 통신이 이뤄지는 1.1과는 달리 2.0에서는 순서에 상관없이 응답을 받고 있습니다.

### Multiplexed Streams

`Multiplexed Streams` 의 특징은 한 커넥션으로 동시에 여러개의 메시지를 통신 할 수 있으며 수신에 있어서 순서가 상관 없다 라는 특징이 있습니다.

### Stream Prioritization

스트림의 우선 순위를 지정하여 웹이 받는 리소스를 보다 효과적으로 제어할 수 있습니다. HTML의 문서를 읽을 때 이미지 파일보다 CSS 파일 수신에 우선 순위를 두는 방식으로 렌더링을 보다 효과적으로 할 수 있습니다.

- HTML 파일을 수신하고 웹 브라우저가 이를 읽는다.
- 우선 순위가 더 높은 CSS파일의 수신이 먼저 이뤄지고 웹 브라우저는 HTML DOM과 CSSOM 구조를 만들어 렌더링을 진행한다.
- 화면에 필요한 이미지 리소스를 요청하고 해당 위치에 렌더링을 진행한다.

### Header Compression

위에서 HTTP/1.1에서는 무거운 헤더 구조가 단점 중 하나로 말했는데 HTTP/2.0에서는 아래와 같은 방식으로 Header를 압축합니다. 이를 HPACK 압축방식이라 부릅니다.

### Server Push

클라이언트가 HTTP 문서를 수신한 후 HTTP/1.1은 리소스 요청이 필요한 라인에서 해당 리소스를 다시 서버에 요청하게 됩니다. 예를 들어서 아래의 과정과 같습니다.

- HTML 구문 분석 중
- CSS 파일을 만났다.
- CSS 파일 요청
- HTML 구문 분석 중
- 이미지 파일을 만났다.
- 이미지 파일 요청

하지만 HTTP/2.0 에서는 클라이언트가 요청할 리소스를 예측하여 해당 정보를 같이 보내는 방법으로 클라이언트의 추가적인 요청을 최소화 해줍니다. 이를 PUSH_PROMISE라고 부릅니다.
