# 캐싱이란?

5 x 3의 결과가 무엇인지 물어보면 답이 15라는 것을 알게 됩니다. 이 곱셈은 인생에서 너무 많이 했기 때문에 더 이상 필요하지 않습니다. 생각을 통해 처리하지 않아도 결과를 기억하기만 하면 됩니다. 이것이 캐싱이 작동하는 방식입니다.

웹 사이트는 일반적으로 한 달에 수백, 수천 또는 수백만 번 조회됩니다. 일반적으로 브라우저가 웹 페이지를 요청할 때마다 서버는 복잡한(그리고 시간 소모적인) 계산을 수행해야 합니다. 최신 게시물을 검색하고 머리글과 바닥글을 생성하고 사이트의 사이드바 위젯을 찾는 등의 작업을 수행합니다. 그러나 대부분의 경우 이러한 모든 계산 결과는 정확히 동일합니다. 그렇다면 각 요청을 개별적으로 처리하는 대신 서버가 최종 결과를 기억하도록 할 수 있다면 좋지 않을까요? 이것이 바로 캐싱이 하는 일입니다.

# 캐싱된 페이지가 제공되는 방법

페이지가 제공되는 방식을 살펴보는 게 캐싱 프로세스를 제일 빨리 이해하는 방법입니다. 캐싱이 활성화 된 블로그를 소유하고 있다고 가정해보겠습니다. 누군가가 귀하의 홈페이지를 처음 방문 할 때 일반적인 방식으로 페이지를 받습니다. 요청이 수신되고 서버에서 처리되고 표시 될 결과 웹 페이지가 HTML 파일로 변환되어 방문자의 웹 브라우저로 전송됩니다.

캐싱이 켜져 있기 때문에 서버는 이 HTML 파일을 저장합니다. 일반적으로 매우 빠른 '무작위 액세스 메모리' (또는 RAM) 내에 있습니다. 다음에 귀하 또는 다른 사람이 홈페이지를 볼 때 서버는 HTML 로의 처리 및 변환을 수행 할 필요가 없습니다. 대신 이미 준비된 HTML 파일을 브라우저로 보냅니다.

### 캐싱된 페이지가 변경된다면 어떻게 될까요?

만약 캐싱된 페이지에서 새로운 게시물을 게시하면 어떻게 될까요? 새 게시물이 캐싱된 페이지 외부에 있어 사이트 방문자에게 보이지 않을까요? 제대로 설정된 캐싱 시스템은 모두 이러한 시나리오를 처리 할 수 있습니다. 캐싱 시스템은 준비된 HTML 파일을 저장하는 메커니즘으로만 구성되는 것이 아니라 특정 조건(예: 새 콘텐츠 생성)이 충족 될 때 캐시를 비운 다음 다시 생성하는 방법도 있습니다.

# 캐싱 정말 효과적일까요?

잘 코딩 된 웹사이트는 2초 이내로 로드 될 수 있습니다. 충분히 빠르지 않나요? 캐싱이 그만한 가치가 있을까요? 대답은 '예' 입니다. 브라우저와 서버 캐싱을 모두 사용함으로써 로딩 시간을 많이 줄일 수 있으며, 로딩 속도에 관해서는 가능한 한 빨리 일을 처리하는 것이 좋습니다.

또한, 캐싱을 구현함으로써 웹 사이트를 더 빠르게 만드는 것이 아니라 더 나은 성능을 제공하고 갑작스러운 트래픽 급증에 대한 부담을 더 효율적으로 감당 할 수 있도록 준비한다는 것입니다.

YUI의 최근 연구에 따르면 브라우저 캐싱은 최대 300%까지 속도를 높일 수 있다고 합니다.

# 캐싱 유형

일반적으로 캐시에는 서버와 브라우저의 두 가지 유형이 있습니다. 

### 브라우저 캐싱

사용자가 웹 브라우저에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, browser 등)에 저장하여, 웹 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있습니다.

### 서버 캐싱

위에서 이미 서버 캐싱의 메커니즘에 대해 이야기했습니다. 모든 요청을 처리하는 대신 서버는 이러한 요청의 결과를 가져와 저장합니다. 그런 다음 대신 저장된 결과를 제공하여 모든 것을 훨씬 더 빠르게 만듭니다.

# HTTP Cache(브라우저 캐시)의 종류

- private (사설) 캐시
    - 한 명의 사용자만 사용하는 캐시
- shared (공유) 캐시
    - 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시

![](https://mdn.mozillademos.org/files/13777/HTTPCachtType.png)

### 사설 브라우저 캐시

사설 캐시는 단일 사용자가 전용으로 사용합니다. 브라우저 설정에서 "caching"을 본 적이 있을 겁니다. 브라우저 캐시는 그 사용자에 의하여 HTTP를 통해 다운로드 된 모든 문서들을 가지고 있습니다. 이 캐시는 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용 할 수 있도록 해 줍니다. 또한 유사한 방법으로 캐시된 컨텐츠의 오프라인 브라우징을 개선시킵니다.

### 공유 프록시 캐시

공유 캐시는 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시입니다. 예를 들어, 당신의 회사의 ISP는 많은 사용자들을 서비스하기 위해 지역 네트워크 기반의 일부분으로서 웹 프록시를 설치해뒀을 수도 있는데, 그 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시(Latency 지연시간)를 줄여줍니다.

# 캐싱 동작의 대상

HTTP 캐싱은 선택적(optional)이지만 캐시된 리소스를 재사용하는 것은 보통 바람직한 일입니다. 하지만, HTTP 캐시들은 일반적으로 GET에 대한 응답만을 캐싱하며, 다른 메서드들은 제외될 겁니다. 기본 캐시 키(primary cache key)는 요청 메서드 그리고 대상 URI로 구성됩니다(GET 요청만을 대상으로 하므로 URI만 사용되는 경우가 많습니다). 일반적인 캐싱 엔트리의 형태는 다음과 같습니다.

- 검색(retrieval) 요청의 성공적인 결과 : HTML 문서, 이미지 혹은 파일과 같은 리소스를 포함하는 GET 요청에 대한 200(OK) 응답
- 영구적인 리다이렉트 : 301 (Moved Permanently) 응답
- 오류 응답 : 404 (Not Found) 결과 페이지
- 그 외

# 캐싱 제어

**Cache-control 헤더**

이 헤더는 HTTP/1.1 기본 헤더 필드로 요청과 응답 양측 모두에 있어 캐싱 메커니즘을 위한 디렉티브(Directive 지시[명령])를 지정하는데 사용됩니다. 이 헤더 필드가 제공하는 여러 디렉티브들로 캐싱 정책을 정의하고자 한다면 이 헤더를 사용하시기 바랍니다.

- 캐시하지 않음 : Cache-Control: no-store
- 캐시하지만 재검증 : Cache-Control: no-cache
- 사설캐시와 공개캐시
    - 사설캐시 : 응답이 단일 사용자만을 위한 것. 공유 캐시에 의해 저장되어서는 안됨.
        - Cache-Control: private
    - 공개캐시 : 응답이 어떤 캐시에 의해서든 캐시되어도 좋다는 것을 가리킵니다.
        - Cache-Control: public
- 만료 : Cache-Control: max-age=31536000
- 검증 : Cache-Control: must-revalidate

**Pragma 헤더**

이 헤더는 HTTP/1.0 헤더입니다. Cache-control 헤더와 비슷한 기능을 하지만 모든 것을 대체 할 수 없습니다. HTTP/1.0 하위 호환성을 위한 경우에만 사용하도록 합니다.

# 캐시 검증

캐시된 문서의 만료 시간이 가까워져오면, 문서가 검증되거나 다시 불러오게 됩니다. 검증은 서버가 강한 검증 혹은 약한 검증 중 하나라도 제공하는 경우에만 일어날 수 있습니다.

- ETags : 이 응답 헤더는 강한 검증으로써 사용될 수 있는 사용자 에이전트에게 있어 불투명한(opaque) 값입니다.
- Last-Modified : 이 응답 헤더는 약한 검증으로써 사용될 수 있습니다. 그것이 1초의 해상도만 가질 수 있기에 약하다고 간주됩니다.

### 출처

- [https://winningwp.com/what-is-website-caching-and-why-is-it-so-important/](https://winningwp.com/what-is-website-caching-and-why-is-it-so-important/)
- [https://developer.mozilla.org/ko/docs/Web/HTTP/Caching](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)