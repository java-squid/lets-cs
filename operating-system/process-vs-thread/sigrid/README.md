# 프로세스와 쓰레드 차이가 뭐에요?
# 프로세스
## 사전적 정의
* 프로세스: OS로부터 자원을 할당받는 작업의 단위
* 쓰레드: 할당받은 자원을 실행하는 실행의 단위
* 즉, Application 1개가 프로세스가 되고 프로세스 내에서 여러 가지 분기 처리를 쓰레드가 담당

```그림4. 여러 Process를 관리하는 운영체제의 모습을 도식화한 모델```
![](https://i.imgur.com/cmfURuf.png)

## 프로레스는 다음을 포함한다
* Stack: 스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값, 등이 저장되고 함수 호출시 기록하고 종료되면 제거한다.
* Data Section: 데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.
* Heap: 힙 영역은 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간(Free Space)이다. 
    * 이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸수 있도록 반납해야 한다. 
    * 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다. 
    * 동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.
* Text Section: 코드 영역은 실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다. CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.
* Program Counter: 프로세스 내부의 레지스터에 위치. 다음에 실행할 명령어의 **주소** 를 갖고 있음.
* 하나의 프로세서는 하나의 프로세스만 처리. 따라서 ready(프로세스에 작업이 할당되기를 기다리거나) waiting(프로세스가 프로세서에 할당되기를 기다리거나) running이거나 셋 중 하나임.


## Context Switching
* 멀티태스킹은 프로세스를 여러 개 동시에 처리하는 개념이 아니다. 대신, CPU는 한 번에 하나의 명령어만 처리할 수 있으므로 동시에 가깝게 Context를 switch해가며 마치 동시에 처리하는 것처럼 보이게 하는 것이다.
* 하나의 프로세스가 CPU를 사용하고 있는 상태에서, 다른 프로세스가 CPU를 활용하도록 하기 위하여 **이전의 프로세스 상태를 보관하고 다음 프로세스의 상태를 적재하는 것이다**
* Context Switching은 OS 내부의 Scheduler에 의해 제어된다. CPU를 효율적으로 사용하고 관리할 수 있는가는 스케줄러에 따라 결정된다.
* 이 작업들이 계속 해서 반복되는데, 이러한 일련과정들을 Context Switching이라고 한다. Context Switching도 메모리에 I/O를 하는 작업이기 때문에 실행되는 프로세스의 수가 많거나, Context Switching의 빈번한 발생은 Overhead를 발생시켜 성능 저하를 가져온다.

## CPU Scheduler
* 프로세스는 System에 들어오면 ```job queue```에 놓여진다.
* 이 중 주 메모리(RAM)에 존재하며 process state가 ready 상태인 프로세스는 ```ready queue```에 다시 놓여진다. ready queue는 linkedlist 형태로 PCB (process control block; 프로그램 카운터, 레지스트리 집합 정보 등 프로세스가 어디까지 갔는지 정보 포함) 를 포인팅하게 된다.

![](https://i.imgur.com/Ua9VTW1.png)

![](https://i.imgur.com/CxMmyVK.png)
* 새로운 프로세스는 처음에 ready queue에 놓인다. 프로세스는 CPU를 할당받을 때(dispatch)까지 ready queue에서 대기한다. 프로세스에 CPU가 할당되어 실행되면 아래 사건들 중 하나가 발생할 수 있다.
    * 프로세스가 I/O(입출력)을 요청하여 I/O queue에 넣어질 수 있다.
    * 프로세스가 child process를 생성하고 그 프로세스의 종료를 기다릴 수 있다.
    * 프로세스가 interrupt의 결과에 따라 강제로 CPU로부터 제거되어 ready queue에 다시 놓일 수 있다.
* 프로세스는 결국 waiting state에서 ready state로 전환되고 다시 ready queue에 넣어진다. 프로세스는 종료될 때까지 이 주기를 계속하며, 종료되면 모든 queue에서 삭제되고 프로세스의 PCB와 자원을 반납(deallocate)한다.
* 스케줄러에는 Long-term과 Short-term 총 2가지가 있다.
    * Long-term: 하드 디스크에서 메모리로 프로세스를 적재(ready)한다. 실행간격이 길다.
        * 메모리에 있는 프로세스의 수를 제어하는데 I/O bound vs CPU bound processes를 적합하게 혼합하는 것이 중요하다.
        * IO 바운드 작업의 경우 input과 output 동작에 더 많은 시간을 할애 하며 CPU 바운드 프로세스는 CPU에서 더 많은 시간을 할애한다. 그래서 균형잡히게 스케줄링을 해야 한다.
    * Short-term: ready 큐에 있는 프로세스 중 어느 것을 running으로 둘 것인지를 선택한다. 실행간격이 짧다. CPU 스케줄러는 높은 burst time을 가지는 프로세스들로 인해 CPU 자원이 'starvation' 하지 않도록 관리해야 한다.
* 스케줄링 알고리즘에는 다음과 같은 것이 있어 간단하게 보고 넘어간다.
    * FCFS: First Come, First Serve 의 약자로, 먼저 도착한 프로세스를 처리하는 스케쥴링
    * SJF: Shorted Job First의 약자로, 최단 작업을 우선하는 스케쥴링
    * Priority Scheduling: 미리 주어진 프로세스의 우선 순위에 따라서 스케쥴링
    * RR: Round Robin의 약자로, 정해진 시간에 주어진 만큼 프로세스를 할당한 뒤 작업이 끝난 프로세스는 레디큐의 가장 마지막에 가서 재할당
    * Multilevel-Queue: 레디큐를 여러개의 큐로 분류하여 각 큐가 각각 다른 스케쥴링 알고리즘을 가지는 방식
    * Multilevel-Feedback-Queue: Multilevel-Queue는 특정 프로세스가 큐에 고정되어 있지만, Multilevel-Feedback-Queue는 큐와 큐 사이에 프로세스가 이동하는 것을 허용

## PCB와 프로세스의 상태
### 개요
![](https://i.imgur.com/Y7r4kGu.png)
* 위 그림을 보면 executing되다가 다른 프로세스 P1을 수행시키기 위해 PCB0에다가 P0프로세스 정보를 저장, 레지스터에 PCB1에 저장되어있던 process 1 정보를 가져와 P1을 수행. 이런 저장공간이 PCB인 것임.
* 사실 이렇게 수행중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것을 Context Switching이라고 하는 것임.
* Context Switching 문맥교환 이란 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정임. 프로세스가 준비 -> 실행, 실행 -> 준비, 실행 -> 대기 등으로 상태 변경될 때 발생
* 즉 PCB가 필요한 이유는 바로 Context Switching 때문
    * CPU가 여러 프로세스를 빠르게 번갈아가면서 작업하기 위해서는 프로세스에 대한 정보 및 상태를 저장/복원 할 필요가 있다.
### 저장 정보
* OS 별로 다르지만, 일반적으로 다음과 같은 정보가 포함된다.
    * 프로세스 식별자(PID;Process ID)
    * 프로세스 상태(Process State)
    ![](https://i.imgur.com/uvObTeM.png)
    * 프로그램 계수기(Program Counter)
    * CPU 레지스터 및 일반 레지스터
    * CPU 스케줄링 정보
    * 메모리 관리 정보
    * 프로세스 계정 정보
    * 입출력 상태 정보
## Inter-Process Communication
### 개요
* 각 프로세스는 별도의 공간에서 실행되기 때문에, 한 프로세스에서 다른 프로세스의 메모리영역에 접근할 수 없다. 프로세스는 자신에게 할당된 메모리 내의 정보만 접근할 수 있는데, 이는 안전성을 위해 운영체제에서 자기 프로세스의 메모리만 접근하도록 강제하고 있다는 것이다.
* 만약 프로세스가 다른 프로세스 자원에 접근하려면 IPC(Inter-Process Commnuication)를 사용해야 한다.
* IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다 IPC의 종류로는 메일슬롯, 파이프, 소켓, 시그널, 공유 메모리 등이 있다.

# 쓰레드
```메모리 관점에서 본 프로세스와 쓰레드```
![](https://i.imgur.com/cAef0R6.png)
* 스레드는 한 프로세스 내에서 동작되는 흐름으로 프로세스 내에서 Stack 영역만 별도로 할당 받고, 부모 프로세스의 Code, Data, Heap 영역은 공유 한다.
* 즉, 프로세스 내에서 자식 스레드들은 서로 주소 공간이나 자원들을 공유하면서 실행될 수 있다.

## 멀티 프로세스 vs 멀티 쓰레드
* Key: 하나의 프로그램을 프로세스로 나눌 것인가, 쓰레드로 나눌 것인가?
### 멀티 프로세스
![](https://i.imgur.com/pnvQ8ZU.png)
* 멀티 프로세스란 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)을 처리하도록 하는 것이다.
    * 장점: 하나의 프로세스가 잘못 되어도 나머지 작업은 잘 처리됨. 구현이 비교적 간단하고, 각 프로세스들이 독립적으로 동작하며 자원의 서로 다르게 할당된다.
    * 단점: Context Switching 비용이 발생함. 프로세스 간 통신을 하기 위해서는 IPC를 통해야 한다. 메모리 사용량이 많다.
### 멀티 쓰레드
![](https://i.imgur.com/xp8m96Z.png)
* 멀티 스레드란 하나의 애플리케이션을 하나의 프로세스 내부에 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것이다.
* 멀티스레드 사용 이유: 사용자와 상호작용하는 애플리케이션에서 단일 스레드로 Network 또는 DB 와 같은 긴 작업(Long-running task) 을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호작용 불능 상태가 되기 때문이다.
    * 장점: 시스템 자원 소모 감소, 자원 공유의 유용성 (쓰레드는 부모 프로세스와 stack 영역 등 자원 및 메모리를 공유). 처리 비용의 감소 (속도의 향상, Context Switching 비용이 없기 때문임).
    * 단점: 동기화와 교착상태에 취약. (추후 CS 스터디 주제로 포함해도 좋겠네요. [참고 링크](https://chanhuiseok.github.io/posts/cs-2/) [참고 링크 2](https://popcorntree.tistory.com/6))
        * 동기화와 비슷하게 [Race 조건](https://close852.tistory.com/68)에 있어서 디버깅하거나 테스트하기가 힘듬. 멀티 쓰레드의 단점은 어느 쓰레드가 먼저 실행될 지를 알 수 없다는 것임.
### 비교
[참고](https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37)
* 멀티 스레드는 멀티 프로세스에 비해 상당한 이점을 가지는 반면 위험 부담 크다.
* 장점
    * 자원의 효율성 증대
        * 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우 프로세스를 생성하여 자원을 할당하는 비용이 적고, 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.
    * 응답 시간 단축 및 처리 비용 감소
        * 프로세스간 IPC를 사용하여 통신하는 것은 상대적으로 비용이 크다.
        * 하지만 스레드는 프로세스의 메모리 영역을 공유하여 스레드 간의 통신 비용이 적게 든다.
        * 또한 프로세스간의 Context Switching은 느린 반면 쓰레드간의 Context Switching 은 빠른데, 그 이유는 Context Switching 시 스레드는 Stack 영역만 처리하면 되기 때문이다.
* 단점
    * 멀티 스레드의 안정성 문제
        * 여러 개의 스레드가 동일한 데이터 공간(Critical Section)을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다.
        * 멀티 프로세스의 프로그램은 문제가 생기면 해당 프로세스가 중단되거나 중단 시키고 다시 시작하면 된다.
        * 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면, 해당 데이터 공간을 공유하는 모든 스레드를 망가뜨릴 수 있다.
* 해결하기 위한 노력
    * 이를 [해결하는 방법](https://chul2-ing.tistory.com/43)은 임계 구역, 세파모어, 뮤텍스 등이 있다고 함. 추후 스터디 주제로!
    * Critical Section: 임계 구역(critical section) 또는 공유변수 영역은 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.
    * Thread Safe: 여러 쓰레드에서 동시에 호출하더라도 멱등성을 보장하는 것을 의미한다. 함수가 전역 변수를 호출하면 thread safe하지 않다고 말하는 이유가 여기에서 있다.
        * 물어볼 수 있는 질문들: 프로세스와 달리 쓰레드는 서로의 자원을 공유하는데 이때 무엇을 조심해야 하는가? [링크](https://brunch.co.kr/@babosamo/100)
            * Thread safe하지 않게 만들 수 있는 방법의 예시는?
            * Thread safe하지 않은 환경을 Thread Safe하게 바꿀 수 있는 방법은?
            * 답변 키워드: 동기화, mutext, semaphore, synchronized
