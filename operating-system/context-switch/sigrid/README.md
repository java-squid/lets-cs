# Context-Switch란 무엇인가?
## 정의
* Running 상태에 있는 프로세스 또는 쓰레드가 사용하는 Context(각 Task가 사용하는 CPU 레지스터의 값)을 메모리의 특정 영역에 저장한 후, 새롭게 수행할 Task의 Context를 TCB 또는 Stack에서 CPU의 레지스터 영역으로 복사하여 새로운 Task가 수행되도록 하는 일련의 작업을 의미한다.

## Context란 무엇인가?
* Context: 각 Task가 사용하는 CPU 레지스터의 값이다.
* 만약 프로세스라면?
    * 텍스트(Text) 영역 : 프로그램의 코드 부분
    * 데이터(Data) 영역 : 프로그램의 전역 변수 부분
    * 스택(Stack) 영역 : 프로그램의 지역 변수 부분
    * 힙(Heap) 영역 : 프로세스의 동적 메모리 할당 영역

* 커널 관리의 프로세스 관련 정보(태스크 구조체, task_struct)
    * 중앙 처리기 범용 레지스터의 내용: 일반적 계산을 위해 활용되는 레지스터들의 내용
    * 중앙 처리기 특수 레지스터의 내용: 프로세스의 실행 위치를 나타내는 프로그램 계수기(Program Counter)
    * 스택 포인터(Stack Pointer), 중앙 처리기 상태 레지스터, 가상 메모리 페이지 테이블 관련 정보 등
    * 프로세스 및 프로세스 그룹 식별자
    * 사용자 정보, 보안 정보				- 오픈 파일 정보
    * 프로세스 상태					- 시그널(Signal) 정보
    * 우선순위, 정책 등의 스케줄링 정보	
    * 부모, 형제, 자식 프로세스 정보			- 타이머(Timer) 정보
    * 메모리 영역 정보					-
    * IPC(Inter-process Communication) 관련 정보

* Context 구성에서, 프로세스 공간 영역은 메모리에 할당되므로 프로세스 사용자 공간이 유지되면 자동 보존된다. 쓰레드 공간 영역은 같은 프로세스 내 공유하므로 자동 보존된다. 아마 함수 호출의 최소 단위로서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당하는 것이다. PCB 레지스터는 쓰레드가 CPU를 할당받았다가 스케쥴러에 의해 다시 선점당하기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 쓰레드도 PC 레지스터를 독립적으로 할당받는다.
* 프로세스 정보와 관련된 모든 문맥은 태스크 구조체(PCB, Process Control Block)에 위 표와 같이 보관되는데, 이들 중 프로세스 중단 시점에서 반드시 보존되고 실행 개시 시점에 복원되어야 하는 것은 대부분 중앙 처리기 레지스터들의 내용이다.
* 즉, 레지스터들의 내용은 중앙 처리기를 차지하는 프로세스가 실행되는 동안 모두 변화되기 때문에, 프로세스 중지 시에는 반드시 보존되었다가 수행 속개 시 다시 복원되어야 한다.
* 리눅스에서 커널의 프로세스 관리 정보를 담은 구조체(PCB)를 task_struct라고 한다. 프로세스가 실행 중 또는 준비 상태일 때는 CPU 별로 할당된 스케줄 큐인 runQueues에서 Linkedlist 형태로 저장된다. 대기 상태일 때는 스케줄링 큐에서 제거되어 대기별 큐(sleep queue)에 속한다.

![](https://i.imgur.com/fkDRqxm.png)
* PCB의 저장 정보는 다음과 같다.
    * 프로세스 상태 : 신규, 준비, 수행, 대기, 정지
    * 프로그램 카운터 : 프로세스가 다음에 실행할 명령어 주소
    * 레지스터 : 누산기, 스택, 색인 레지스터
    * 프로세스 번호

## 스케줄링 기법
* Dispatching
    * Ready 상태의 프로세스 또는 쓰레드 중에서 우선순위가 가장 높은 프로세스에 CPU 할당
* Time Quantum
    * 특정 프로세스 또는 쓰레드에 할당되는 시간의 단위를 설정하여, 특정 프로세스 또는 쓰레드의 CPU 독점을 방지
* Preemption
    * Time Quantum이 초과하면 인터럽트를 통해 CPU 사용권을 빼앗는 스케줄링 기법

## Context-Switch의 진행 과정
### 진행 시점
![](https://i.imgur.com/qwaMHjm.png)
* 비자발적 문맥교환 (현 프로세스나 쓰레드가 원치 않은데 커널에 따라 강제로 교환당하는 경우)
    * 인터럽트의 처리 및 시스템 호출 완료 직후 사용자 모드로의 복귀 이전에 스케줄러가 수행되며 이 때 우선 순위가 현재 프로세스 보다 높은 프로세스가 있으면 비자발적 문맥 교환(involuntary context switch)이 일어난다.
    * 현 프로세스의 타임 슬라이스가 다 소진된 경우도 클럭 인터럽트 처리 과정에서 이러한 사실을 알게 되고, 이때에도 인터럽트 처리를 마치고 사용자 모드로 복귀하는 과정에서 문맥 교환이 발생한다.
    * 타임 슬라이스(Time Slice) 소진 시, 인터럽트(Interrupt) 발생 시
* 자발적 문맥교환
    * 프로세스 자신이 잠들 때(Sleep)
    * 프로세스가 Exit 할 때
    * 시스템 호출로부터 사용자 모드로 돌아왔으나 실행될 가장 적당한 프로세스가 아닐 때(wait)
    * 커널이 인터럽트 처리를 마치고 프로세스가 사용자 모드로 돌아왔으나 실행될 가장 적당한 프로세스가 아닐 때 (wait)

### 진행과정
![](https://i.imgur.com/C2ZcfhF.png)
```
    ① Interrupt나 시스템 호출에 의해 문맥 교환 요구

    ② 사용자 Mode -> 운영체제 모드

    ③ 기존 프로세스의 현재 H/W 상태정보를 PCB에 저장 (PCB: Process Control Block)

    ④ 다음에 실행할 프로세스의 상태정보를 PCB에서 복구한 후 다음 프로세스를 실행함

    ⑤ 운영체제 모드 -> 사용자 Mode로 전환
```
* Context-Switching 과정에서 발생하는 오버헤드
    * 1단계: 현 프로세스
    * 2단계: Interrupt 처리 루틴
        * 현재 상태를 PCB에 저장하는 오버헤드
    * 3단계: 프로세스 스케쥴러
        * 다음 실행 프로세스를 준비 Queue에서 선택
    * 4단계: Dispatch
        * 다음 Process의 PCB값 복구
    * 5단계: 다음 프로세스 지정
    * 해결 방안:
        * Context Switch 자주 발생하지 않도록 다중 프로그래밍의 정도를 낮춤
        * 스택 중심의 장비에서는 Stack 포인터 레지스터를 변경하여 프로세스간 문맥교환 수행
        * Light Weight Process인 스레드를 이용하여 Context Switch 부하를 최소화시킴

## 쓰레드 중심의 Context-Switching은 어떨까?
### 의의
* 스레드는 실행에 필요한 최소한의 정보만을 가지고 자신이 속해 있는 프로세스의 기억장치나 파일과 같은 실행환경을 공유하여 프로세스의 생성과 문맥교환 등의 오버헤드를 줄일 수 있다.
* 병행성 증진: 단일 프로세스에서 다수의 스레드 생성 및 수행
* 오버헤드 감소: 실행 환경의 공유를 통해 오버헤드 줄임
### 실행 절차
![](https://i.imgur.com/SfjYQ12.png)
* CPU 내에 존재하는 레지스터들은 현재 실행 중인 프로세스 관련 데이터들로 채워짐(T0)  (실행 중인 프로세스가 변경되면, CPU 내에 존재하는 레지스터들의 값이 변경되어야 함)
* 프로세스 T1이 실행되기 전에, 현재 T0 레지스터들이 지니고 있는 데이터들을 저장
* 프로세스 T1은 Ready 상태로 바뀌고, 프로세스 T1와 관련된 메모리에 백업된 레지스터 정보를 Restore하여 수행
* 프로세스 T1은 마지막 실행 이후를 이어서 실행
* 프로세스 T0 관련 레지스터 정보는 메모리에 저장되고, 프로세스 T1 관련 레지스터 정보는 CPU의 레지스터에 복원

### 참고: 언제 Interrupt가 이루어질까?
* I/O request (입출력 요청할 때)
* time slice expired (CPU 사용시간이 만료 되었을 때)
* fork a child (자식 프로세스를 만들 때)
* wait for an interrupt (인터럽트 처리를 기다릴 때)

### Reference
* http://jidum.com/jidums/view.do?jidumId=442
* https://jeongchul.tistory.com/94
* https://jeong-pro.tistory.com/93
