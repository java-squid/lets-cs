# 리눅스 메모리 관리 기법 간단히 알아보기
* 여러 프로세스를 동시에 실행하는 경우 프로세스 크기가 서로 달라 메모리를 어떻게 나누어 사용할지에 대한 문제가 생긴다.
## 가상 메모리 Virtual Memory
* 가상 메모리는 메모리 사용량이 늘어나면서, HDD/SDD의 일부를 확장 RAM처럼 사용할 수 있도록 하는 기술이다.
* 커널은 실제 메모리(RAM)에 올라간 메모리 블록들 중 당장 쓰이지 않는 것을 디스크에 저장한다. 이를 통하여 사용 가능한 메모리 영역을 늘릴 수 있다.
* 만약 디스크에 저장되었던 메모리 블록이 다시 필요하게 되면, 해당 블록을 RAM에 다시 올린다. 대신 다른 블록을 디스크로 내린다.
* 하지만 HDD/SDD를 읽고 쓰는 시간은 RAM보다 약 천배 정도 느리기 때문에 프로그램 실행은 그만큼 더디게 된다.
* 가상 메모리로 쓰이는 HDD/SDD의 영역을 Swap space라고 한다.
* CPU가 특정 프로세스의 어떤 공간을 참조할 때는 우선 가상 주소를 먼저 참조하고, 가상 주소에 해당하는 실제 물리 주소를 참조하게 된다.
## MMU
* CPU가 가상 메모리에 접근하기 위해 물리 메모리의 가상 주소를 참조할 때마다 매번 이를 물리 주소로 변환을 하게 되니까 이 시간을 짧게 하려고 MMU라는 하드웨어 칩의 지원을 받는다. MMU는 가상 주소를 물리 주소로 빠르게 변환해주는 역할을 한다.
* 프로세스 생성 시 물리 메모리 레지스터(PCB)에 페이지 테이블 정보가 생성된다.
* PCB 등에서 해당 페이지 테이블에 접근이 가능하고, 관련 정보는 물리 메모리에 적재한다.
* 프로세스 구동 시, 해당 페이지 테이블의 base 주소 (시작 주소)가 별도의 레지스터(CR3)에 저장된다.
* 즉 CPU가 가상 주소에 접근 시, MMU가 CR3를 통해 페이지 테이블 base 주소에 접근해서 물리 주소를 가져온다.

## 연속 할당 기법
* 프로그램 전체를 하나의 공간에 연속적으로 할당하는 기법이다.
* 고정 분할 할당(정적 할당)
    * 프로그램 전체가 주 기억장치에 위치해야 한다.
    * 주기억장치 고정된 크기로 분할한다. 프로그램이 분할된 영역보다 클 경우 들어갈 수 없다. 내부, 외부 단편화 발생하여 낭비가 많다.
* 가변 분할 할당(동적 할당)
    * 고정 분할 기법처럼 미리 분할해놓는 것이 아니라 프로그램을 주기억장치에 적재 시 필요한 크기로 분할한다. 고정 분할 기법보다 단편화를 줄일 수 있지만 영역과 영역 사이 단편화가 발생할 수 있다.

## 비연속 할당 기법(분산 할당 기법)
* 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당한다.
* 하나의 프로세스에서 특정 시간 동안 쓰는 메모리 영역은 4GB 중 아주 일부분이기 때문에 일부분만 실제 물리 메모리에 올려놓고 쓰자는 것이 가상 메모리의 컨셉이다.
* 이 때 정도의 사이즈만큼 메모리에 올릴 지에 대한 결정이 필요하다(100MB? 1GB? 등). 이를 페이지(page)라는 단위로 다루겠다고 하는 것이 바로 페이징 시스템이다.
### 페이징
* 가상 메모리를 일정한 크기로 나눈 블록
* 크기가 동일한 페이지 단위
* 가상 주소 공간과 이에 매칭되는 물리 주소 공간을 관리
* 페이지 번호를 기반으로 가상 주소와 물리 주소의 매핑 정보를 기록하고 사용
    * 리눅스의 경우 4GB의 가상 메모리를 4KB 단위로 쪼개서 페이징하고 페이지 번호를 붙임
    * 페이지 단위로 물리 메모리에 넣고, 해당 데이터를 찾을 때에도 페이지 번호를 기반으로 주소를 찾게 된다.

### 프레임
* 물리 메모리를 일정한 크기로 나눈 블록(page와 동일한 크기)
* 프로세스(4GB)의 PCB(Process Control Block)에 Page Table 구조체를 가리키는 주소가 들어 있음
* Page Table에는 가상 주소와 물리 주소 간 매핑 정보가 있음
![](https://i.imgur.com/TS55cDT.png)

### 페이지 테이블
* 가상 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
```
가상 주소 v = (p, d)라면
p: 페이지 번호
d: 페이지 처음부터 떨어진 정도 (위치)
```

## 세그멘테이션 기법
* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할하는 기법
    * 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할하는 것과 대조됨
* [외부 단편화](https://m.blog.naver.com/rbdi3222/220623825770)가 일어나기 쉽다. 평균 세그먼트의 크기가 작을 수록 외부 단편화 문제는 줄어든다.
### 주소 변환
* 주소 변환을 위해 세그먼트의 위치 정보를 가지고 있는 세그먼테이션 매핑 테이블이 필요하다.
* 이 테이블은 limit(세그먼트 크기)과 base(물리 메모리상의 시작 주소 정보)를 갖는다.
* 가상 주소를 (S,D)로 표현한다. S는 세그먼트의 No이고, D는 세그먼트 시작 지점에서 해당 주소까지의 거리를 의미한다. 물리주소는 ```base[S]+D``` 로 계산한다.
```
No	limit	base
0	280	    120
1	120	    450
2	100	    630
…	…	…
```
* 논리주소 (2, 100) => 물리주소 630+100 = 730번지
* 논리주소 (1, 200) => 거리가 세그먼트의 크기(120)보다 크기 때문에 메모리 관리자는 해당 프로세스를 강제 종료한다. (trap(사용자가 의도치 않게 일으키는 인터럽트)을 발생시킴)

### 참고: 단편화 문제 Fragmentation Problem
* 내부 단편화 문제(Internal Fragmentation Problem) - (페이지 기법)
    * 페이지 블록만큼 데이터가 딱 맞게 채워져 있지 않을 때 공간 낭비
* 외부 단편화 문제(External Fragmentation Problem) - (세그멘테이션 기법)
    * 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우

## 참고
* http://egloos.zum.com/sweeper/v/2988689
* https://velog.io/@gndan4/OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC
* https://colinch4.github.io/2020-02-02/%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95/
* https://higunnew.tistory.com/61
* https://www.geeksforgeeks.org/difference-between-paging-and-segmentation/
