# B-tree vs B+tree

### B-tree

B-tree는 노드가 inorder traversal로 정렬되는 자가 균형 이진 탐색 트리(self-balancing tree)로 알려져 있습니다. B-tree에서 노드는 둘 이상의 자식을 가질 수 있습니다. B-tree의 높이는 logMN 입니다. (여기서 M은 트리 순서, N은 노드 수입니다) 그리고 높이는 업데이트 할 때마다 자동으로 조정됩니다. B-tree에서 데이터는 왼쪽이 가장 낮은 값, 오른쪽이 가장 높은 값을 사용하여 특정 순서로 정렬됩니다. B-tree에 데이터나 키를 삽입하는 것은 이진 트리보다 더 복잡합니다. B-tree가 유지해야 하는 몇 가지 조건이 있습니다.

- 모든 리프 노드는 동일한 수준에 있어야 한다.
- 리프 노드 위에는 빈 하위 트리가 없어야 한다.
- 높이는 가능한 한 낮아야 한다.

![](https://media.geeksforgeeks.org/wp-content/uploads/20191219160544/Untitled-Diagram111.png)

### B+tree

B+tree는 트리의 리프 노드에만 데이터 포인터를 저장하여 인덱싱에 사용되는 B-tree의 단점을 제거합니다. 따라서 B+tree의 리프 노드 구조는 B-tree의 내부 노드 구조와 상당히 다릅니다. 데이터 포인터는 리프 노드에만 존재하기 때문에 리프 노드는 액세스하기 위해 디스크 파일 블록에 대한 해당 데이터 포인터와 함께 모든 키값을 반드시 저장해야 합니다. 또한 리프 노드는 레코드에 대한 정렬된 액세스를 제공하는데 연결됩니다(Moreover, the leaf nodes are linked to providing ordered access to the records). 따라서 리프 노드는 인덱스의 첫 번째 level을 형성하며 내부 노드는 multilevel 인덱스의 다른 level을 형성합니다. 리프 노드의 일부 주요 값은 내부 노드에도 나타나며, 단순히 레코드 검색을 제어하는 매체 역할을 합니다.

![](https://media.geeksforgeeks.org/wp-content/uploads/Btree.jpg)

<br>


|No|B-tree|B+tree|
|:---|:---|:---|
|1. |모든 내부 및 리프 노드에는 데이터 포인터가 있습니다.|리프 노드에만 데이터 포인터가 있습니다.|
|2. |리프에서 모든 키를 사용 할 수 없기 때문에 검색에 더 많은 시간이 걸리는 경우가 많습니다.|모든 키는 리프 노드에 있으므로 검색이 더 빠르고 정확합니다.|
|3. |트리에서 키의 중복이 유지되지 않습니다.|중복 키가 유지되고 모든 노드가 리프에 있습니다.|
|4. |삽입에 더 많은 시간이 걸리며 때로는 예측 할 수 없습니다.|삽입이 더 쉽고 결과는 항상 동일합니다.|
|5. |내부 노드의 삭제는 매우 복잡하고 트리는 많은 변형을 거쳐야합니다.|모든 노드가 리프에서 발견되기 때문에 모든 노드의 삭제가 쉽습니다.|
|6. |리프 노드는 구조적(structural) 연결리스트로 저장되지 않습니다.|리프 노드는 구조적 연결리스트로 저장됩니다.|
|7. |중복 검색 키가 없습니다.|중복 검색 키가 있을 수 있습니다.|

### 출처
- https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/